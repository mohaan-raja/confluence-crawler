<h1>Title: DevOps: Creating new docker setup in staging</h1><p><br/></p><ol><li><p class="auto-cursor-target">Install required gems, Update freshsales_source_code_path in the script, and create a directory to save the output files and update its path in the script, save this file</p></li><li><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>docker-setup.rb</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: false; theme: Confluence" data-theme="Confluence">require &#39;aws-sdk-s3&#39;
require &#39;aws-sdk-acm&#39;
require &#39;aws-sdk-route53&#39;
require &#39;aws-sdk-opsworks&#39;
require &#39;aws-sdk-cloudfront&#39;
require &#39;json&#39;
require &#39;httparty&#39;
require &#39;byebug&#39;
require &#39;active_support/all&#39;

STATUS = { INTIATE: 0, CREATED_S3_BUCKET: 1, CREATED_CLOUDFRONT_DISTRIBUTION: 2, CREATED_SSL_CERTIFICATE: 3, CREATED_STACK: 4, BOOTED_SPOTINST: 5, BOOTSTRAPED: 6, CREATED_REDSHIFT_DB: 7, MANUAL_COMMANDS: 8}.freeze

@options = {
    stack_for: &#39;harsh&#39;,
    email: &#39;harsh.kumar@freshworks.com&#39;,
    reference_docker_prefix: &#39;dwarak&#39;,
    stack_region: &#39;us-east-1&#39;,
    freshsales_source_code_path: &#39;/Users/‚Å®dwarak/freshsales&#39;,
    output_folder_path: &#39;/Users/dwarak/output&#39;,
    base_pgsql_path: &#39;/Users&#39;,
    redshift_port: 5439, #reference
    redshift_db: &#39;dwarak&#39;, #reference
    redshift_user: &#39;fs_usr_admin&#39;,
    redshift_host: &#39;staging-report.cdyawqmnysyw.us-east-1.redshift.amazonaws.com&#39;,
    access_key_id: nil,
    secret_access_key: nil,
    route_53_hosted_zone_id: &#39;Z1AJ3BVLC16748&#39;, #freshmarketeer.com
    status: 0
}


def signin_into_opsworks
  puts &quot;Signing to OpsWorks...Please Wait...&quot;
  @opsworks = Aws::OpsWorks::Client.new(:region =&gt; @options[:stack_region], :credentials =&gt; fetch_credentials)
end

def fetch_credentials
  @creds ||= Aws::Credentials.new(@options[:access_key_id], @options[:secret_access_key])
end

def fetch_all_stacks(refresh = false)
  if refresh
    @all_stacks = @opsworks.describe_stacks[:stacks]
  end
  @all_stacks ||= @opsworks.describe_stacks[:stacks]
end

def check_stack_already_exists_or_not
  puts &quot;Stack already exists with same name or not...&quot;
  current_stacks = fetch_all_stacks.select { |stack| stack.name.include?(&quot;#{@options[:stack_for]}-&quot;) || stack.name.include?(&quot;-#{@options[:stack_for]}&quot;) }.map(&amp;:name)
  if current_stacks.any?
    puts &quot;Cannot create stack for : #{@options[:stack_for]}. Conflicting stacks : #{current_stacks.inspect}&quot;
    update_status(STATUS[:CREATED_STACK])
  end
  puts &quot;No name conflicts...Can create a stack with this name...&quot;
  # press_enter
end

def create_new_bucket
  s3 = Aws::S3::Client.new(region: @options[:stack_region], :credentials =&gt; fetch_credentials)
  puts &quot;Listing all buckets in AWS...&quot;

  bucket_name = &quot;freshsales-assets-#{@options[:stack_for]}&quot;
  already_present = s3.list_buckets({}).buckets.select { |bucket| bucket.name.eql?(bucket_name) }.map(&amp;:name)

  unless already_present.empty?
    puts &quot;Bucket Already Exists With name : #{bucket_name}&quot;
  else
    puts &quot;Creating asset bucket for app : #{bucket_name}...&quot;
    s3.create_bucket(bucket: bucket_name)
    puts &quot;Updating CORS for asset bucket : #{bucket_name}...&quot;
    s3.put_bucket_cors({
                           bucket: bucket_name,
                           cors_configuration: { cors_rules: [{ allowed_headers: [&quot;Content-*&quot;], allowed_methods: [&quot;GET&quot;], allowed_origins: [&quot;*&quot;], max_age_seconds: 3000 }]}
                       })
    # press_enter
  end
end

def create_new_cloudfront_distribution
  cloudfront = Aws::CloudFront::Client.new(region: @options[:stack_region], :credentials =&gt; fetch_credentials)
  puts &quot;Listing all cloudfront distributions...&quot;

  already_present = cloudfront.list_distributions.distribution_list.items.select { |distribution| distribution.origins.items[0].domain_name.include?(&quot;freshsales-assets-#{@options[:stack_for]}.s3.amazonaws.com&quot;) }.first

  if already_present
    puts &quot;Using Previously Created CloudFront distribution itself...&quot;
    @cloudfront_details = already_present
  else
    puts &quot;Creating CloudFront distribution...&quot;
    created_distribution = cloudfront.create_distribution({
                                                              distribution_config: {
                                                                  caller_reference: &quot;dist-for-#{@options[:stack_for]}&quot;,
                                                                  origins: {
                                                                      quantity: 1,
                                                                      items: [{ id: &quot;S3-freshsales-assets-#{@options[:stack_for]}&quot;, domain_name: &quot;freshsales-assets-#{@options[:stack_for]}.s3.amazonaws.com&quot;, s3_origin_config: {origin_access_identity: &quot;&quot;} }],
                                                                  },
                                                                  default_cache_behavior: {
                                                                      target_origin_id: &quot;S3-freshsales-assets-#{@options[:stack_for]}&quot;,
                                                                      forwarded_values: { query_string: false, cookies: { forward: &quot;none&quot; }, headers: { quantity: 1, items: [&quot;Origin&quot;] } },
                                                                      trusted_signers: { enabled: false, quantity: 0 },
                                                                      viewer_protocol_policy: &quot;allow-all&quot;,
                                                                      min_ttl: 0,
                                                                      allowed_methods: { quantity: 2, items: [&quot;HEAD&quot;, &quot;GET&quot;], cached_methods: { quantity: 2, items: [&quot;HEAD&quot;, &quot;GET&quot;] } },
                                                                      smooth_streaming: false,
                                                                      default_ttl: 86400,
                                                                      max_ttl: 31536000,
                                                                      compress: false,
                                                                  },
                                                                  comment: &quot;&quot;,
                                                                  price_class: &quot;PriceClass_All&quot;,
                                                                  enabled: true
                                                              }
                                                          })
    @cloudfront_details = created_distribution[:distribution]
  end
  # press_enter
end

def create_new_certificate
  acm = Aws::ACM::Client.new(:region =&gt; @options[:stack_region], :credentials =&gt; fetch_credentials)
  domain_name = &quot;*.#{@options[:stack_for]}.freshmarketeer.com&quot;

  puts &quot;Listing all Certificates...&quot;
  already_present = acm.list_certificates({ certificate_statuses: [&quot;PENDING_VALIDATION&quot;, &quot;ISSUED&quot;] }).certificate_summary_list.select { |cert| cert.domain_name == domain_name }.first

  if already_present
    puts &quot;Certificate already exists with domain : &#39;#{domain_name}&#39;...Please Check manually...&quot;
  else
    resp = acm.request_certificate(domain_name: domain_name, validation_method: &#39;DNS&#39;)
    puts &quot;Certificate for #{@options[:stack_for]} is requested...Please approve it...&quot;
    sleep(5)
    requested_cert = acm.describe_certificate(certificate_arn: resp.certificate_arn)
    ar53 = Aws::Route53::Client.new(region: @options[:stack_region], :credentials =&gt; fetch_credentials)
    verification_record = requested_cert.certificate.domain_validation_options[0]
    ar53.change_resource_record_sets(
        {change_batch: {
            changes: [{action: &#39;CREATE&#39;,
                          resource_record_set:
                              {name:  verification_record.resource_record.name,
                               resource_records: [{value: verification_record.resource_record.value}],
                               ttl: 300,
                               type: &#39;CNAME&#39;}}]
        },
         hosted_zone_id: @options[:route_53_hosted_zone_id]
        })
    puts &#39;Added domain verification records in route 53...&#39;
  end
  # press_enter
end

def create_new_stack
  puts &quot;Getting stack config from &#39;#{@options[:reference_docker_prefix]}-docker&#39;...&quot;
  reference_stack = fetch_all_stacks.select { |stack| stack.name == &quot;#{@options[:reference_docker_prefix]}-docker&quot; }.first
  custom_json = JSON.parse(reference_stack.custom_json.gsub(@options[:reference_docker_prefix], @options[:stack_for]))

  puts &quot;Updating stack settings json with new details...&quot;
  custom_json[&quot;freshsales&quot;][&quot;config/asset_sync.yml&quot;][&quot;staging&quot;][&quot;asset_host_url_https&quot;] = &quot;https://#{@cloudfront_details.domain_name}&quot;
  custom_json[&quot;freshsales&quot;][&quot;config/asset_sync.yml&quot;][&quot;staging&quot;][&quot;opsworks_stack_name&quot;] = &quot;#{@options[:stack_for]}-docker&quot;
  custom_json[&quot;assets&quot;][&quot;https_url&quot;] = @cloudfront_details.domain_name
  custom_json[&quot;assets&quot;][&quot;cloudfront_distribution&quot;] = @cloudfront_details.id

  puts &quot;Cloning stack...&quot;
  @stack = @opsworks.clone_stack({
                                     source_stack_id: reference_stack.stack_id,
                                     name: &quot;#{@options[:stack_for]}-docker&quot;,
                                     attributes: {&quot;Color&quot;=&gt;&quot;rgb(57, 131, 94)&quot;},
                                     service_role_arn: reference_stack.service_role_arn,
                                     custom_json: JSON.pretty_generate(custom_json),
                                     clone_permissions: true,
                                     clone_app_ids: @opsworks.describe_apps(stack_id: reference_stack.stack_id)[:apps].map(&amp;:app_id)
                                 })
  @layer_id = @opsworks.describe_layers(stack_id: @stack.stack_id).layers.first.layer_id
  # press_enter
end

def delete_stack
  return unless @stack.present?
  puts &#39;Do you want to delete stack? (y/n)&#39;
  return unless check_yes
  @opsworks.describe_apps(stack_id: @stack.stack_id)[:apps].map(&amp;:app_id).each { |a| @opsworks.delete_app(app_id: a) }
  @opsworks.delete_stack(stack_id: @stack.stack_id)
  puts &#39;Stack deleted...&#39;
end



def create_and_boot_spot_inst
  elastigroup_config = spotinst_request(&#39;get_elastigroup&#39;, &quot;#{@options[:reference_docker_prefix]}-docker&quot;)
  puts &quot;Using reference docker spotinst configuration...&quot;
  elastigroup_config = replace_params(elastigroup_config, @stack.stack_id, @layer_id)
  spotinst_request(&#39;create_elastigroup&#39;, elastigroup_config)
  puts &quot;Created elastigroup in spotinst...&quot;
  # press_enter
end

def replace_params(existing_params, stack_id, layer_id)
  existing_params.except!(&#39;id&#39;,&#39;createdAt&#39;,&#39;updatedAt&#39;)
  existing_params[&#39;name&#39;] = &quot;#{@options[:stack_for]}-docker&quot;
  existing_params[&#39;compute&#39;][&#39;launchSpecification&#39;][&#39;userData&#39;] = Base64.encode64(get_user_data(stack_id, layer_id)).gsub(/\n/,&#39;&#39;)
  existing_params[&#39;thirdPartiesIntegration&#39;][&#39;opsWorks&#39;][&#39;layerId&#39;] = layer_id.to_s
  existing_params[&#39;compute&#39;][&#39;availabilityZones&#39;] = existing_params[&#39;compute&#39;][&#39;availabilityZones&#39;].map {|zone| zone.slice(&#39;name&#39;,&#39;subnetIds&#39;)}
  { &#39;group&#39; =&gt;  existing_params }
end

def get_user_data(stack_id, layer_id)
  &quot;#!/bin/bash
  curl -fsSL https://s3.amazonaws.com/spotinst-public/integrations/opsworks/spotinst_aws_opsworks_v5.sh | \
  OPSWORKS_STACK_TYPE=\&quot;CLASSIC\&quot; \
  OPSWORKS_STACK_ID=\&quot;#{stack_id}\&quot; \
  OPSWORKS_LAYER_ID=\&quot;#{layer_id}\&quot; \
  bash
  sudo mount /dev/sdb /data&quot;
end

def spotinst_request(method, param)
  case method

  when &#39;get_elastigroup&#39;
    r = HTTParty.get(&#39;https://api.spotinst.io/aws/ec2/group&#39;,
                 query: { &#39;accountId&#39; =&gt; &#39;act-4d7f5f6d&#39;, &#39;name&#39; =&gt; param},
                 headers: {&#39;Authorization&#39; =&gt; &#39;Bearer f3efa47a85a306befae57d7debbe614b9e11339d45e698e2e57aa6fafcb3b022&#39;,
                           &#39;Content-Type&#39; =&gt; &#39;application/json&#39;}
                 )
    r[&#39;response&#39;][&#39;items&#39;].first
    return r[&#39;response&#39;][&#39;items&#39;].first
  when &#39;create_elastigroup&#39;
    r = HTTParty.post(&#39;https://api.spotinst.io/aws/ec2/group&#39;,
                  query: { &#39;accountId&#39; =&gt; &#39;act-4d7f5f6d&#39;},
                  headers: {&#39;Authorization&#39; =&gt; &#39;Bearer f3efa47a85a306befae57d7debbe614b9e11339d45e698e2e57aa6fafcb3b022&#39;,
                            &#39;Content-Type&#39; =&gt; &#39;application/json&#39;},
                  body: param.to_json
    )
    if r[&quot;response&quot;][&quot;status&quot;][&quot;code&quot;] == &#39;200&#39;
      puts &quot;Created #{r[&quot;response&quot;][&quot;status&quot;][&quot;code&quot;]}&quot;
    end
  end
end

def create_redshift_db
  puts &quot;\nReading from #{@options[:freshsales_source_code_path]}...\nPlease Wait..&quot;
  pgsql_content = &quot;CREATE DATABASE #{@options[:stack_for]};\n\\c #{@options[:stack_for]};\n&quot;
  Dir[&quot;#{@options[:freshsales_source_code_path]}/config/redshift/*.sql&quot;].each do |file_name|
    pgsql_content += &quot;\n&quot; + File.open(file_name).read.gsub(&#39;freshsales&#39;, @options[:stack_for])
  end

  pgsql_content = pgsql_content.sub(&quot;  contact_status_id NUMERIC(20, 0) ENCODE MOSTLY32,\n&quot;, &#39;&#39;)
  pgsql_content += &quot;GRANT ALL ON TABLE contact TO fs_usr_admin;\nGRANT ALL ON TABLE deal TO fs_usr_admin;\nGRANT ALL ON TABLE lead TO fs_usr_admin;\nGRANT ALL ON TABLE sales_account TO fs_usr_admin;\nGRANT ALL ON TABLE contact_deal_association TO fs_usr_admin;\nGRANT SELECT ON TABLE contact TO fs_usr_readonly;\nGRANT SELECT ON TABLE deal TO fs_usr_readonly;\nGRANT SELECT ON TABLE lead TO fs_usr_readonly;\nGRANT SELECT ON TABLE sales_account TO fs_usr_readonly;\nGRANT SELECT ON TABLE contact_deal_association TO fs_usr_readonly;\nCOMMIT;\n&quot;

  pgsql_file_path = &quot;#{@options[:output_folder_path]}/#{@options[:stack_for]}.pgsql&quot;
  File.open(pgsql_file_path, &#39;w+&#39;) do |file|
    file.write(pgsql_content)
    file.close
  end

  command = &quot;PGPASSWORD=freshreportAdmin321 psql --host=#{@options[:redshift_host]} --port=#{@options[:redshift_port]} --user=#{@options[:redshift_user]} --dbname=#{@options[:redshift_db]} &lt; #{pgsql_file_path}&quot;
  puts &quot;executing command - #{command}&quot;
  `#{command}`
  press_enter
end

def generate_other_needed_commands
  puts &quot;Generating needed Commands ...\nReading from #{@options[:freshsales_source_code_path]}...\nPlease Wait...&quot;


  file_content = &quot;&quot;
  file_content += &quot;\n\n*********** Gmail Auth Callbacks Setup ***********\n\n&quot;
  file_content += &quot;Login to - https://console.developers.google.com/apis/credentials/oauthclient/1017055921322-k7i8o85lld9s1uv250phb55l93e79bos.apps.googleusercontent.com?project=freshmarketeer-86\n&quot;
  file_content += &quot;Add these urls in the client-\n&quot;
  file_content += &quot;https://login.#{@options[:stack_for]}.freshmarketeer.com/auth/google_oauth2/callback\n&quot;
  file_content += &quot;https://login.#{@options[:stack_for]}.freshmarketeer.com/integrations/oauth2/google_calendar/callback\n&quot;
  file_content += &quot;https://login.#{@options[:stack_for]}.freshmarketeer.com/integrations/oauth2/google_contacts/callback\n\n&quot;

  file_content += &quot;Login to - https://console.developers.google.com/apis/credentials/oauthclient/167958100302-71mg7bcv1lje40mp9ej1scv7jb0d0qdm.apps.googleusercontent.com?project=freshsales-admin-dev\n&quot;
  file_content += &quot;Add these urls in the client-\n&quot;
  file_content += &quot;https://admin.#{@options[:stack_for]}.freshmarketeer.com:4000/users/auth/google_oauth2/callback\n\n&quot;

  file_content += &quot;Login to - https://console.developers.google.com/apis/credentials/domainverification?project=freshmarketeer-86\n&quot;
  file_content += &quot;Add these urls in the client-\n&quot;
  file_content += &quot;gcalendar.#{@options[:stack_for]}.freshmarketeer.com\n&quot;
  file_content += &quot;https://console.aws.amazon.com/route53/home?#resource-record-sets:Z1AJ3BVLC16748&quot;

  file_content += &quot;\n\n********** All Urls ***********\n\n&quot;
  file_content += &quot;Email Address: #{@options[:email]}\n&quot;
  file_content += &quot;Freshsales Application Development Account URL : &quot;
  file_content += &quot;https://development.#{@options[:stack_for]}.freshmarketeer.com/\n&quot;
  file_content += &quot;Admin Console URL : https://admin.#{@options[:stack_for]}.freshmarketeer.com:4000/\n&quot;

  File.open(&quot;#{@options[:output_folder_path]}/#{@options[:stack_for]}.txt&quot;, &#39;w+&#39;) do |file|
    file.write(file_content)
    file.close
  end

  puts &quot;file store in #{@options[:output_folder_path]}#{@options[:stack_for]}.txt&quot;
  puts File.read(&quot;#{@options[:output_folder_path]}/#{@options[:stack_for]}.txt&quot;)
end

def initialize_stack_and_instance_details
  @stack = fetch_all_stacks(true).select { |stack| stack.name.include?(&quot;#{@options[:stack_for]}-docker&quot;) }.first
  if @stack.nil?
    puts &quot;Stack not Found with name : #{@options[:stack_for]}&quot;
    exit (0)
  end
  wait_till_instance_has_ip
end

def fetch_staging_instance
  return @staging_instance unless @staging_instance.nil?
  staging_stack = fetch_all_stacks.select { |stack| stack.name.include?(&quot;staging-rails&quot;) }.first
  @staging_instance = @opsworks.describe_instances(stack_id: staging_stack.stack_id)[:instances].select { |instance| instance.hostname.include?(&quot;appserver&quot;) }.first
end

def wait_till_instance_has_ip(retry_time = 0)
  puts
  loop do
    @instance = @opsworks.describe_instances(stack_id: @stack.stack_id)[:instances].first
    if !(@instance.present? &amp;&amp; @instance.public_ip.present? &amp;&amp; @instance.status == &#39;online&#39;)
      sleep(2)
      print &#39;.&#39;
    else
      puts &quot;\nWaiting for docker containers to boot...&quot;
      sleep(600) # wait for docker containers to boot
      return
    end
  end
end

def run_bootstrap_recipe
  initialize_stack_and_instance_details if @instance.nil?
  fetch_staging_instance if @staging_instance.nil?

  &quot;Running bootstrap recipe in the instance...&quot;
  resp = @opsworks.create_deployment({stack_id: @stack.stack_id, instance_ids: [@instance.instance_id],
                                      command: { name: &quot;execute_recipes&quot;, args: { &quot;recipes&quot; =&gt; [&quot;docker::db_bootstrap&quot;] } },
                                      comment: &quot;Bootstrap&quot;,
                                      custom_json: JSON.pretty_generate({bootstrap: { apps: [&quot;freshsales&quot;,&quot;freshsales_admin&quot;], domain: &quot;development&quot;, email: @options[:email]}}),
                                  })

end

def show_and_get_input
  loop do
    puts &#39;Current Configuration&#39;
    puts JSON.pretty_generate(@options)

    puts &quot;\nDo you wish to change configurations? (y/n)&quot;
    return unless check_yes

    @options.keys.each do |k|
      if @options[k]
        puts &quot;\n#{k}: #{@options[k]}\n(&#39;ENTER&#39; to proceed / &#39;y&#39; to change): &quot;

        next unless check_yes
      end

      puts &quot;\nEnter value for #{k}:&quot;
      new_value = gets
      @options[k] = new_value.strip
    end
  end
end

def check_yes
  response = gets
  response.strip!
  response == &#39;y&#39; || response == &#39;Y&#39; || response == &#39;Yes&#39; || response == &#39;yes&#39; || response == &#39;yeah&#39; || response == &#39;Yeah&#39;
end

def press_enter
  puts &quot;\n\npress ENTER to proceed&quot;
  gets
end

def wait_for_confirmation(t)
  loop do
    sleep(1)
    3.times.each do |i|
      print &#39;.&#39;
      sleep(1)
    end
    puts t
    return if check_yes
  end
end

def update_status(status)
  @options[:status] = status if @options[:status] &lt; status
end

def docker_create_interaction

  show_and_get_input

  signin_into_opsworks

  check_stack_already_exists_or_not if @options[:status].zero?

  create_new_bucket if @options[:status] &lt;  STATUS[:CREATED_S3_BUCKET]
  update_status(STATUS[:CREATED_S3_BUCKET])

  create_new_cloudfront_distribution if @options[:status] &lt;  STATUS[:CREATED_CLOUDFRONT_DISTRIBUTION]
  update_status(STATUS[:CREATED_CLOUDFRONT_DISTRIBUTION])

  create_new_certificate if @options[:status] &lt;  STATUS[:CREATED_SSL_CERTIFICATE]
  update_status(STATUS[:CREATED_SSL_CERTIFICATE])

  create_new_stack if @options[:status] &lt;  STATUS[:CREATED_STACK]
  update_status(STATUS[:CREATED_STACK])

  create_and_boot_spot_inst if @options[:status] &lt;  STATUS[:BOOTED_SPOTINST]
  update_status(STATUS[:BOOTED_SPOTINST])
  puts &quot;Stack created successfully... Wait for instance to boot&quot;

  # wait_for_confirmation(&quot;\nHas the instance created under stack? (y/n)&quot;)
  # wait_for_confirmation(&quot;\nIs the instance &#39;setup&#39; over? (y/n)&quot;)

  run_bootstrap_recipe if @options[:status] &lt;  STATUS[:BOOTSTRAPED]
  update_status(STATUS[:BOOTSTRAPED])

  create_redshift_db if @options[:status] &lt;  STATUS[:CREATED_REDSHIFT_DB]
  update_status(STATUS[:CREATED_REDSHIFT_DB])

  generate_other_needed_commands
rescue =&gt; e
  puts &quot;Error: #{e.message}\n #{e.backtrace.take(10).join(&quot;\n&quot;)}&quot;
  delete_stack
end
# COMMAND TO RUN: ruby create_docker_with_spotinst.rb

docker_create_interaction
</pre>
</div></div></li><li>Update the &quot;stack-for&quot; and &quot;email&quot; values and run the script.</li><li>The above script will create docker stack, and will also add and boot an instance.</li><li>The script would also generate a file with path - 'output_folder_path/stack_for.txt' - ex - '/Users/reshmauma/output/reshma.txt', <br/>which would contain other necessary commands to be run manually, such as <br/>registering domains in google dev console.</li></ol>