<h1>Title: Setting up remote choices in Freshsales</h1><h3 id="SettingupremotechoicesinFreshsales-Problemstatement:">Problem statement:</h3><p><span style="color: rgb(29,28,29);">We have use cases where customer are expecting 50K+ choices for certain custom dropdown fields. As of now, we only support 300 choices for dropdown fields from Product UI.<br/></span></p><h3 id="SettingupremotechoicesinFreshsales-Solution:">Solution:</h3><p><span style="color: rgb(29,28,29);">When such requests come, we handle it from backend offline scripts  for exclusive customers.</span><span style="color: rgb(29,28,29);">What we do is create a separate secondary form with this custom field  and have choices only as part of that secondary form.<br/>Even primary form also will have this field with a reference to secondary form and field. We will be referring secondary form when we need choices for that field using that reference.</span></p><p><span style="color: rgb(29,28,29);"><br/></span><span style="color: rgb(29,28,29);">Reason why we need to store this field in secondary form is to avoid making primary form heavy as we will accessing Primary form in many places in the application and it will increase the form loading time. It's like side loading or on demand loading kind of approach.</span></p><p>This doc lists out steps to setup remote choices in freshsales with the remote choices being stored in Formservice.</p><p>refer this doc <a href="https://confluence.freshworks.com/pages/viewpage.action?pageId=219350855">Support for filtering of choices in Formserv</a> for the API architecture.</p><h3 id="SettingupremotechoicesinFreshsales-stepstocreateremotechoicesmultiselectfield">steps to create remote choices multiselect field</h3><ol><li>find entity form service form id from sequel pro eg it will be in lead form, contact form table etc. copy that service-form-id</li><li>open<span> </span><a style="text-decoration: none;" href="https://formserv-staging.freshworksapi.com/" rel="nofollow" class="external-link">formserv-staging.freshworksapi.com</a><br/>3.open Forms tab and in Get tag: retrieve the existing form by pasting the copied service-form-id.</li><li>Copy the response of the existing form</li><li>taking that response as base, create a secondary form with a sample multiselect field</li><li>update that new field with 80000 choices</li><li>no go to the first form field and update its properties<br/>link: /search/auto_suggest/get_field_choices/{secondary_form_doc_id}/{field_id}<br/>field_options: { ..., &quot;is_formserv_link&quot;: &quot;true&quot; }</li></ol><h3 id="SettingupremotechoicesinFreshsales-Thingstonote">Things to note</h3><ul><li><span style="color: rgb(32,33,36);">choices text should be trimmed</span></li><li><span style="color: rgb(32,33,36);">remote choice URL ie link attribute should start with ''/...&quot;</span></li><li><span style="color: rgb(32,33,36);">is_formserv_link: should be &quot;true&quot; as a string in field_options when storing in formserv</span></li><li><span style="color: rgb(32,33,36);">remove all choices from the selected field when setting up the remote choices</span></li></ul><h3 id="SettingupremotechoicesinFreshsales-Beforerunningscripts:">Before running scripts:</h3><ol><li>please ensure you read the README.md before starting</li><li>change the configurations available at the beginning of each script as needed.</li></ol><p><br/></p><p><strong>Scripts:</strong></p><ul><li class="auto-cursor-target"><span class="s1">Step 1 - temporarily increase the max allowed choices</span></li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">Increase choice limit</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">def increase_formula_limit(account_id)
  Sharding.select_shard_of(account_id) do
    account_record = FdMultitenant::Account.find(account_id).make_current
    acc_sett = account_record.account_setting
    puts acc_sett.configs
    acc_sett.configs['form_meta'] = (acc_sett.configs['form_meta'] || {}).merge(max_choices_allowed_per_field: 1000)
    acc_sett.save
    puts acc_sett.configs
  end
end

</pre>
 </div>
</div><p><br/></p><ul><li class="auto-cursor-target">Step 2 - create secondary form and copy existing choices over, mark choices as empty in primary form</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">create_secondary_form</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">def create_secondary_form(account_id, primary_form_class, field_name)
  Sharding.select_shard_of(account_id) do
    account = FdMultitenant::Account.find(account_id).make_current
    is_sales_360 = account.sales_360_account || account.has_feature?(:sales_360)
    puts "is_sales_360 #{is_sales_360}"
    form_key = is_sales_360 &amp;&amp; ['Contact', 'SalesAccount'].include?(primary_form_class) ? FORMSERV_CONFIG['api_tokens']['sales_360'] : FORMSERV_CONFIG['api_tokens']['default']
    puts "form_key #{form_key}"
 
    primary_form = account.cached_default_form_for(primary_form_class)
    primary_form_field = primary_form.find_field_by(:name, field_name)
    puts primary_form_field.name
  
    field_body = ['name', 'column_name', 'label', 'position', 'type',
                  'custom', 'editable', 'visible', 'deleted',
                  'validatable', 'builder', 'internal', 'field_class',
                  'placeholder', 'default_value', 'hint'].each_with_object({}) do |property, field_hash|
                    field_hash[property] = primary_form_field.send(property.to_sym)
                  end
  
    field_body['account_id'] = account_id.to_s
    field_body['form_id'] = '1'
	# https://github.com/freshdesk/formserv-gem/blob/master/lib/formserv/constants.rb
    field_body['type'] = '18'
    field_body['choices'] = primary_form_field.super_choices.each_with_object([]) do |super_choice, choices_list|
                              choices_list &lt;&lt; ['id', 'value', 'position', 'editable', 'custom'].each_with_object({}) do |property, choice_hash|
                                choice_hash[property] = super_choice.send(property.to_sym)
                              end.merge({ 'account_id' =&gt; account_id.to_s })
                            end
  
    secondary_form_body = {
      "account_id" =&gt; account_id.to_s,
      "form_id" =&gt; '1',
      "coll_id" =&gt; "#{primary_form_class}Form",
      "prod_id" =&gt; "Freshsales",
      "name" =&gt;  "#{primary_form_class} secondary Form",
      "title" =&gt;  "#{primary_form_class} secondary Form",
      "description" =&gt;  "#{primary_form_class} secondary Form",
      "active" =&gt; true,
      "fields" =&gt;  [field_body]
    }
  
    secondary_form_post_args = {
      headers: {
        'Content-Type' =&gt; 'application/json',
        'Accept' =&gt; 'application/json',
        'Authorization' =&gt; form_key
      },
      path: FORMSERV_CONFIG['formserv_url'],
      type: :post,
      body: secondary_form_body
    }
    puts "secondary_form_post_args :: #{secondary_form_post_args}"
    secondary_form_response = UtilityServices::Request.new(secondary_form_post_args).send
  
    if secondary_form_response.success?
      secondary_form_response_body = JSON.parse(secondary_form_response.body)
      secondary_form_doc_id = secondary_form_response_body['docId']
      secondary_form_field_id = secondary_form_response_body['fields'].find { |fld| fld['name'] == primary_form_field.name }['id']
  
      puts "Secondary Form doc ID :: #{secondary_form_doc_id}"
      puts "Secondary Field ID :: #{secondary_form_field_id}"
  
      primary_field_get_args = {
        headers: {
          'Content-Type' =&gt; 'application/json',
          'Accept' =&gt; 'application/json',
          'Authorization' =&gt; form_key
         },
        path: FORMSERV_CONFIG['formserv_url'] + "/#{primary_form.service_form_id}/fields/#{primary_form_field.id}",
        type: :get,
        body: {}
      }
  
      primary_field_get_response = UtilityServices::Request.new(primary_field_get_args).send
  
      if primary_field_get_response.success?
        primary_field_response_body = JSON.parse(primary_field_get_response.body)
        puts "primary_field_response_body :: #{primary_field_response_body}"
        # Add link
        primary_field_response_body['link'] = "/search/auto_suggest/get_field_choices/#{primary_form_class}/#{secondary_form_doc_id}/#{secondary_form_field_id}"
        # Remove choices
        primary_field_response_body['choices'] = []
        # Alter field options
        primary_field_response_body['field_options'] = primary_field_response_body['field_options'].merge('is_formserv_link' =&gt; 'true')

        primary_field_response_body['field_options'].merge('reference' =&gt; true)
  
        primary_field_put_args = {
          headers: {
            'Content-Type' =&gt; 'application/json',
            'Accept' =&gt; 'application/json',
            'Authorization' =&gt; form_key
          },
          path: FORMSERV_CONFIG['formserv_url'] + "/#{primary_form.service_form_id}/fields/#{primary_form_field.id}",
          type: :put,
          body: primary_field_response_body
        }
        puts "primary_field_put_args ::: #{primary_field_put_args}"
        primary_field_put_response = UtilityServices::Request.new(primary_field_put_args).send
  
        if primary_field_put_response.success?
          account.reset_forms_cache_for(primary_form_class)
          account.reset_forms_cache_for(primary_form_class.underscore.downcase)
          puts "SUCCESS!! DONE WITH SECONDARY FORM CREATION AND PRIMARY FIELD UPDATION"
        else
          puts "Primary Field PUT failed"
        end
      else
        puts "Primary Field GET failed"
      end
    else
      puts "Secondary Form POST failed"
    end
  end
end &nbsp;</pre>
 </div>
</div><ul><li class="auto-cursor-target">Step 3 - populate [new script - update using form.update_field method]</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">populate_choices_new</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">require 'csv'
ACCOUNT_ID = 1651745403
IMPORT_FILE = 'file.csv'
FIELD_MAPPINGS = {
  'Country': {
    'primary_form': true,
    'form_class': 'Contact',
    'mapped_field': 'cf_country_4',
  },
  'State': {
    'primary_form': true,
    'form_class': 'Contact',
    'mapped_field': 'cf_state_4',
  },
  'City': {
    'primary_form': true,
    'form_class': 'Contact',
    'mapped_field': 'cf_city_4',
  },
  'Zipcode': {
    'primary_form': false,
    'form_class': 'Contact',
    'mapped_field': 'cf_zipcode_4',
    'form_doc_id': '6f98d911-4795-4b40-a500-595b42dfc02d',
    'form_field_id': '95ff8d4b-2dcd-46de-b881-c96b2c631a5c',
  },
}




def read_import_file(file_name)
  csv_text = File.read(file_name)
  csv = CSV.parse(csv_text, :headers =&gt; true)
  import_hash = []
  csv.each do |row|
    import_hash &lt;&lt; row.to_hash
  end
  import_hash
end


def write_json(file_name, data)
  File.open(file_name, 'w') do |f|
    f.write(data.to_json)
  end
end


def filter_unique_values(key, field)
  values = []
  @items.each do |item|
     values &lt;&lt; item[key.to_s] if !item[key.to_s].nil?
  end
  values.uniq
end


def get_primary_form_field(field)
  form = @account.cached_default_form_for(field[:form_class])
  return nil if form.blank? || form.nil?
  form.find_field_by(:name, field[:mapped_field])
end



def get_form_field(field)
  if field[:primary_form]
    # !* - fetch form field from primary form
    form = @account.cached_default_form_for(field[:form_class])
    return nil if form.blank? || form.nil?
    form.find_field_by(:name, field[:mapped_field])
  else
    # * - fetch form field from secondary form
    is_sales_360 = @account.sales_360_account || @account.has_feature?(:sales_360)
    form_key = is_sales_360 &amp;&amp; ['SalesAccount', 'Contact'].include?(field[:form_class]) ? FORMSERV_CONFIG['api_tokens']['sales_360'] : FORMSERV_CONFIG['api_tokens']['default']
    headers = { 'Content-Type' =&gt; 'application/json', 'Accept' =&gt; 'application/json', 'Authorization' =&gt; form_key }
    req = {
      headers: headers, type: :get,
      path: FORMSERV_CONFIG['formserv_url'] + "/#{field[:form_doc_id]}/fields/#{field[:form_field_id]}"
    }
    resp = UtilityServices::Request.new(req).send
    JSON.parse(resp.body)
  end
end


def save_form_choices(mapped_key, field)
  mapped_field = field[:mapped_field]
  form_field = get_form_field(field)
  choice_ids = {}
  if field[:primary_form]
    form_field.choices.each do |ch|
      choice_ids[ch[:value]] = ch[:id]
    end
  else
    form_field['choices'].each do |ch|
      choice_ids[ch['value']] = ch['id']
    end
  end
  write_json("#{mapped_field}.json", choice_ids)
end


def insert_into_form(mapped_key, field)
  prefix = '[inserting into form] '
  mapped_field = field[:mapped_field]
  puts "#{prefix} populating choices for field #{mapped_key} :: #{mapped_field}"
  form_field = get_primary_form_field(field)
  return if form_field.blank?

  values = filter_unique_values(mapped_key, mapped_field)
  puts "#{prefix} total new unique choices #{values.length}"
  return if values.length &lt;= 0

  last_postion = form_field.choices.present? ? form_field.choices.last[:position] || 0 : 0
  choices_to_add = values.map { |ch | { :id =&gt; nil, :value =&gt; ch, :position =&gt; last_postion += 1 } }
  # puts "#{prefix} choices_to_add #{choices_to_add}"

  form = @account.cached_default_form_for(field[:form_class])
  form.update_field(form_field.id, choices: choices_to_add, skip_callbacks: true)
  @account.reset_forms_cache_for(field[:form_class])
  @account.reset_forms_cache_for(field[:form_class].underscore.downcase)
end



def run_script()
  Sharding.select_shard_of(ACCOUNT_ID) do
    @account = FdMultitenant::Account.find_by_id(ACCOUNT_ID)
    if @account.blank?
      puts "cannot find requested account"
      return;
    end
    @account.make_current

    puts "starting to populate choices ..."
    @items = read_import_file(IMPORT_FILE)
    puts "total items in csv file #{@items.length}"

    FIELD_MAPPINGS.each do |mapped_key, field|
      puts "*" * 30
      insert_into_form(mapped_key, field)
      save_form_choices(mapped_key, field)
      puts "*" * 30
    end

    puts "completed choices population"
  end
end

run_script()</pre>
 </div>
</div><ul><li class="auto-cursor-target">Step 4 - update dependencies</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">update_dependencies</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">require 'csv'

ACCOUNT_ID = 1651745403
IMPORT_FILE = 'file.csv'
FIELD_MAPPINGS = {
  'Country': {
    'form_class': 'Contact',
    'mapped_field': 'cf_country_4',
    'primary_form': true,
    'depends': {}
  },
  'State': {
    'form_class': 'Contact',
    'mapped_field': 'cf_state_4',
    'primary_form': true,
    'depends': {
      'csv_field': 'Country',
      'form_class': 'Contact',
      'mapped_field': 'cf_country_4',
      'primary_form': true
    }
  },
  'City': {
    'form_class': 'Contact',
    'mapped_field': 'cf_city_4',
    'primary_form': true,
    'depends': {
      'csv_field': 'State',
      'form_class': 'Contact',
      'mapped_field': 'cf_state_4',
      'primary_form': true
    }
  },
  'Zipcode': {
    'form_class': 'Contact',
    'mapped_field': 'cf_zipcode_4',
    'primary_form': false,
    'form_doc_id': '6f98d911-4795-4b40-a500-595b42dfc02d',
    'form_field_id': '95ff8d4b-2dcd-46de-b881-c96b2c631a5c',
    'depends': {
      'csv_field': 'City',
      'form_class': 'Contact',
      'mapped_field': 'cf_city_4',
      'primary_form': true
    }
  },
}


def read_import_file(file_name)
  csv_text = File.read(file_name)
  csv = CSV.parse(csv_text, :headers =&gt; true)
  import_hash = []
  csv.each do |row|
    import_hash &lt;&lt; row.to_hash
  end
  import_hash
end


def write_json(file_name, data)
  File.open(file_name, 'w') do |f|
    f.write(data.to_json)
  end
end

def read_json(file_name)
  JSON.parse(File.read(file_name))
end


def filter_unique_values(key, field)
  values = []
  @items.each do |item|
     values &lt;&lt; item[key.to_s] if !item[key.to_s].nil?
  end
  values.uniq
end

# ! controlling field is in primary form
def generate_field_dependency(mapped_key, field)
  prefix = '[primary form] '
  depends = field[:depends]
  mapped_field = field[:mapped_field]
  if depends.nil? || depends.empty?
    puts "#{prefix} dependency update not required for #{mapped_key} :: #{mapped_field}"
    return
  end
  puts "#{prefix} updating dependency for #{mapped_key} :: #{mapped_field}"

  choice_ids = read_json("#{field[:mapped_field]}.json")
  # puts "#{prefix} choice_ids #{choice_ids}"

  csv_field = depends[:csv_field]
  parent_mapped_field = depends[:mapped_field]
  puts "#{prefix} parent field :: #{csv_field} :: #{parent_mapped_field}"

  results = {}
  @items.each do |item|
    if results[item[csv_field.to_s]].nil?
      results[item[csv_field.to_s]] = [item[mapped_key.to_s]]
    else
      results[item[csv_field.to_s]] &lt;&lt; item[mapped_key.to_s]
    end
  end
  results.each do |c_field, d_choices|
    results[c_field] = d_choices.map { |ch| choice_ids[ch] }
    results[c_field] = results[c_field].uniq
  end
  # puts "#{prefix} dependency results #{results}"

  if depends[:primary_form]
    puts "#{prefix} controlling field is in the primary form"

    form = @account.cached_default_form_for(field[:form_class])
    form_field = form.find_field_by(:name, field[:mapped_field])
    parent_field = form.find_field_by(:name, depends[:mapped_field])
    puts "#{prefix} parent field :: #{parent_field.id}"
    choices = []
    parent_field.choices.map do |ch|
      if results[ch[:value]].present?
        ch[:dependent_ids] = {
          choice: results[ch[:value]],
          field: []
        }
      end
      choices &lt;&lt; ch
    end

    request = {
      field_dependency_configuration: {
        dependent_field: {
          id: form_field.id
        },
        controlling_field: {
          id: parent_field.id,
          choices: choices,
          field_options: {
            dependent_choice_ids_for_none: '',
            dependent_field_ids_for_none: '',
            dependent_required_field_ids_for_none: '',
            unique: 'false'
          },
        },
      }
    }
    # puts "request #{mapped_field}_request.json :: #{request}"
    write_json("#{mapped_field}_request.json", request)

    config = @account.field_dependency_configurations.new
    config.attributes = {
      controlling_field_id: parent_field.id,
      dependent_field_id: form_field.id,
      form_class: field[:form_class],
      form_id: form.id
    }
    puts "creating dependency now .."
    # puts "choices : #{choices}"
    res = config.save_and_create_mapping_in_form(field_options: request[:field_dependency_configuration][:controlling_field][:field_options],
                                          cf_choices: request[:field_dependency_configuration][:controlling_field][:choices])
    puts "dependency result : #{res}"
    @account.reset_forms_cache_for(field[:form_class])
    @account.reset_forms_cache_for(field[:form_class].underscore.downcase)
  else
    puts "#{prefix} controlling field is in the secondary form"
  end
end



def run_script()
  Sharding.select_shard_of(ACCOUNT_ID) do
    @account = FdMultitenant::Account.find_by_id(ACCOUNT_ID)
    if @account.blank?
      puts "cannot find requested account"
      return;
    end
    @account.make_current
    @admin_user = @account.user_with_higesh_privilege
    if @admin_user.blank?
      puts "cannot find admin user"
      return;
    end
    @admin_user.make_current

    puts "starting to updated dependencies ..."
    @items = read_import_file(IMPORT_FILE)
    puts "total items in csv file #{@items.length}"

    FIELD_MAPPINGS.each do |mapped_key, field|
      puts "*" * 30
      generate_field_dependency(mapped_key, field)
      puts "*" * 30
    end

    puts "completed updating dependencies"
  end
end

run_script()

</pre>
 </div>
</div><ul><li class="auto-cursor-target">Step 5 - manually update zipcode choice ids</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">update_zip_ids</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">def update_choices(account_id, model, field_name, choices)
  Sharding.select_shard_of(account_id) do
    account = FdMultitenant::Account.find(account_id)
    account.make_current
    form = FdMultitenant::Account.current.cached_default_form_for(model)
    field = form.find_field_by(:name, field_name)
    return if field.blank?

    form.update_field(field.id, choices: choices, skip_callbacks: true)
    puts "updated field choices"
    account.reset_forms_cache_for(model)
    account.reset_forms_cache_for(model.underscore.downcase)
  end
end


def read_json(file_name)
  JSON.parse(File.read(file_name))
end

choices = read_json('cf_zipcode_1_request.json')

update_choices(1648123656, 'SalesAccount', 'cf_city_1', choices['field_dependency_configuration']['controlling_field']['choices']) </pre>
 </div>
</div><ul><li class="auto-cursor-target">Step 6 - add reference option to field</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">add_reference_option</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">def update_field(account_id, model, field_name)
  Sharding.select_shard_of(account_id) do
    account = FdMultitenant::Account.find(account_id)
    account.make_current
    form = account.cached_default_form_for(model)
    field = form.find_field_by(:name, field_name)
    return if field.blank?

    puts "field_options #{field.field_options}"

    options = field.field_options
    options['reference'] = true
    res = form.update_field(field.id, field_options: options)
    puts "result #{res}"
    account.reset_forms_cache_for(model)
    account.reset_forms_cache_for(model.underscore.downcase)
  end
end

update_field(1648123656, 'SalesAccount', 'cf_zipcode_1') &nbsp;</pre>
 </div>
</div><ul><li class="auto-cursor-target">README.md</li></ul><div class="code panel pdl" style="border-width: 1px;">
 <div class="codeHeader panelHeader pdl hide-border-bottom" style="border-bottom-width: 1px;">
  <b class="code-title">README.md</b><span class="collapse-source expand-control" style="display:none;"><span class="expand-control-icon icon">&nbsp;</span><span class="expand-control-text">Expand source</span></span><span class="collapse-spinner-wrapper"></span>
 </div>
 <div class="codeContent panelContent pdl hide-toolbar">
  <pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: ruby; gutter: true; theme: Confluence; collapse: true" data-theme="Confluence">0. create required fields through SSO

1. increase the formula limit for the customer using increase_formula_limit.rb script

2. run the set_remote_choices.rb on zipcodes field

3. change the configs in the populate.rb and run

4. change the configs in dependency.rb and run

5. copy the request.json name for zipcodes and run the update_ids.rb script

6. add reference: true in the field options using add_reference_option.rb script


Atom BE things to comment out before running scripts

lib/form_service/common_field_methods.rb:19
  if field.custom &amp;&amp; (field.dom_type.in?(%i[dropdown checkbox radio]) || (field.field_class == 'Product' &amp;&amp; field.type.to_sym.in?(%i[dropdown checkbox radio]))) &amp;&amp; !(field.respond_to?(:has_remote_choices?) &amp;&amp; field.has_remote_choices?) # fields with remote choices not supported in field-dep by formserv for now!


lib/form_service/common_field_methods.rb:35
  return false if !field.editable || field.default_dropdown_as_autocomplete? || (field.respond_to?(:has_remote_choices?) &amp;&amp; field.has_remote_choices?) # fields with remote choices not supported in field-dep by formserv for now!

</pre>
 </div>
</div><p><a href="/display/freshsales/Setting+up+remote+choices+in+Freshsales?preview=%2F223786168%2F362491365%2Ffile.csv"><span style="background: url('/s/-j2fuir/9012/1ca6q62/18.5.15/_/download/resources/com.atlassian.confluence.plugins.confluence-view-file-macro:view-file-macro-resources/images/placeholder-medium-file.png'); width: 250px; height: 95px; display: inline-block; padding-top: 155px; margin: 2px; border: 1px solid #ddd; text-align: center; vertical-align: text-bottom; text-decoration: none; font-size: 12px; color: #000;">file.csv</span></a></p>